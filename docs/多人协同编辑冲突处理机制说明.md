# 多人协同编辑冲突处理机制说明

## 一、问题背景

当多个用户通过 OnlyOffice 同时编辑同一个文档时，会存在**并发冲突**的风险。本系统通过**基于 baseVersion 的乐观锁机制**来检测和处理这些冲突。

## 二、当前实现机制

### 2.1 保存时的行为（无冲突检测）

当用户通过 OnlyOffice 保存文档时（触发 `FORCE_SAVE` 回调），系统会：

1. **下载编辑后的文件**（从 OnlyOffice 服务器）
2. **保存为新文件**（`saveEditedFile` 方法）
3. **创建新的草稿版本**（`createVersionFromFileEdit` 方法）

```java
// OnlyOffice 回调 -> 创建新版本
KnowledgeDTO updatedKnowledge = knowledgeService.createVersionFromFileEdit(
    knowledge.getId(), 
    newFile.getId(), 
    operatorUsername, 
    userId, 
    "通过OnlyOffice编辑更新"
);
```

**关键点**：
- ✅ **每次保存都会创建新版本**（版本号递增）
- ✅ **草稿的 `baseVersion` 设置为当前已发布版本**（`originalPublishedVersion`）
- ✅ **不会检测冲突**（保存时不检测，因为草稿可以并存）

### 2.2 冲突检测时机（发布时）

冲突检测**不是在保存时进行**，而是在**用户想要发布草稿时**进行。

当用户点击"发布"按钮时，系统会调用 `checkMergeStatus` 方法：

```java
// 冲突检测逻辑（checkMergeStatus 方法）
Long draftBaseVersion = draftVer.getBaseVersion();  // 草稿基于的版本
Long currentPublishedVersion = knowledge.getPublishedVersion();  // 当前发布版本

// 关键检测：如果草稿基于的版本 != 当前发布版本，说明有其他版本发布了
if (!draftBaseVersion.equals(currentPublishedVersion)) {
    // 检测到冲突，需要进行三方合并
    DiffUtil.MergeResult mergeResult = DiffUtil.merge(
        baseContent,      // 草稿基于的版本内容
        targetContent,    // 当前发布版本内容
        incomingContent   // 草稿内容
    );
    
    if (mergeResult.isHasConflict()) {
        // 有冲突，需要手动解决
        throw new MergeConflictException("检测到并发冲突，请手动解决");
    } else {
        // 无冲突，可以自动合并
        // 使用合并后的内容发布
    }
}
```

## 三、冲突场景分析

### 场景 1：无冲突情况（Fast-Forward）

```
时间线：
T1: 发布版本 v1 (publishedVersion=1)
T2: 用户A开始编辑，基于 v1 创建草稿 v2 (baseVersion=1)
T3: 用户B开始编辑，基于 v1 创建草稿 v3 (baseVersion=1)
T4: 用户A保存 -> 创建草稿 v2
T5: 用户B保存 -> 创建草稿 v3
T6: 用户A发布草稿 v2 -> 检测：baseVersion(1) == publishedVersion(1) ✓ 无冲突，直接发布
    -> publishedVersion 变成 2
T7: 用户B发布草稿 v3 -> 检测：baseVersion(1) != publishedVersion(2) ✗ 检测到冲突
```

### 场景 2：有冲突情况（Lost Update）

```
时间线：
T1: 发布版本 v1
T2: 用户A基于 v1 创建草稿 v2 (baseVersion=1)
T3: 用户B基于 v1 创建草稿 v3 (baseVersion=1)
T4: 用户A保存草稿 v2
T5: 用户B保存草稿 v3
T6: 用户A发布草稿 v2 -> 成功，publishedVersion 变成 2
T7: 用户B尝试发布草稿 v3 -> 冲突！

冲突分析：
- 用户B的草稿 v3 基于 v1，但当前发布版本已经是 v2
- 如果直接发布 v3，会覆盖用户A的修改（用户A在 v1->v2 的修改会丢失）
```

### 场景 3：冲突自动解决（Auto Merge）

如果用户B的修改与用户A的修改**不冲突**（修改的是文档的不同部分），系统可以自动合并：

```java
// 三方合并：Base(v1) vs Target(v2) vs Incoming(v3)
// 如果 v2 和 v3 修改的是不同区域，可以自动合并
DiffUtil.MergeResult mergeResult = DiffUtil.merge(baseContent, targetContent, incomingContent);
if (!mergeResult.isHasConflict()) {
    // 自动合并成功，使用合并后的内容发布
    String mergedContent = mergeResult.getMergedContent();
    // 创建新版本 v4，内容是合并后的内容
}
```

### 场景 4：冲突需要手动解决

如果用户B的修改与用户A的修改**冲突**（修改的是同一区域），系统会：

1. **标记冲突**：返回冲突详情，包含冲突的代码块
2. **显示冲突预览**：前端显示三方对比视图（Base / Current / Draft）
3. **用户手动解决**：用户选择保留哪边的修改，或者手动编辑合并结果
4. **使用解决后的内容发布**：调用 `mergeAndPublish(resolvedContent)` 发布

## 四、OnlyOffice 保存时的潜在问题

### 4.1 问题：保存时不会检测冲突

**当前实现**：
- OnlyOffice 每次保存（`FORCE_SAVE`）都会创建新版本
- **不会检测是否有其他用户在编辑**
- **不会检测是否基于的版本已被更新**

**潜在风险**：
1. **版本号快速递增**：多个用户频繁保存会产生大量草稿版本
2. **无法提前发现冲突**：只有在发布时才知道有冲突，用户体验不佳

### 4.2 当前行为（代码实现）

```java
// OnlyOffice 回调处理（OnlyOfficeController.java）
@PostMapping("/callback")
public Map<String, Object> callback(...) {
    if (status == 2 || status == 6) {  // FORCE_SAVE 或 自动保存
        // 直接创建新版本，不检测冲突
        createNewVersionFromEdit(fileId, downloadUrl, userName, userId);
    }
}
```

**结论**：
- ✅ 保存时可以正常创建版本（不会报错）
- ❌ 不会在保存时检测冲突
- ✅ 冲突检测在**发布时**进行
- ⚠️ 如果多个用户同时保存，会产生多个草稿版本，但不会冲突（因为都是草稿）

## 五、冲突处理流程

### 5.1 完整的冲突处理流程

```
1. 用户A和用户B同时打开文档编辑
   ↓
2. 用户A保存 -> 创建草稿 v2 (baseVersion=1)
   ↓
3. 用户B保存 -> 创建草稿 v3 (baseVersion=1)
   ↓
4. 用户A发布草稿 v2
   ├─> 检测：baseVersion(1) == publishedVersion(1) ✓
   └─> 发布成功，publishedVersion 变成 2
   ↓
5. 用户B尝试发布草稿 v3
   ├─> 检测：baseVersion(1) != publishedVersion(2) ✗
   ├─> 触发冲突检测
   ├─> 获取三方内容：Base(v1) / Target(v2) / Draft(v3)
   ├─> 执行三方合并：DiffUtil.merge(...)
   ├─> 判断结果：
   │   ├─> 无冲突：自动合并，创建新版本 v4（合并后的内容）
   │   └─> 有冲突：返回冲突详情，要求用户手动解决
   └─> 用户解决冲突后，使用解决后的内容创建新版本
```

### 5.2 代码实现位置

**冲突检测**：`KnowledgeServiceImpl.checkMergeStatus()`（第 1866 行）

**三方合并**：`DiffUtil.merge()`（knowledge-common 模块）

**冲突解决**：`KnowledgeServiceImpl.mergeAndPublish()`（第 1975 行）

## 六、实际使用建议

### 6.1 对于用户

1. **频繁保存无问题**：可以随时保存，不会报错
2. **发布时检查冲突**：如果提示冲突，需要查看冲突详情并手动解决
3. **查看版本历史**：可以通过版本历史查看所有草稿和发布版本

### 6.2 对于开发者

**如果要改进，可以考虑**：

1. **保存时预检测**：在保存时就检测是否有冲突风险，提示用户
2. **实时冲突提示**：使用 WebSocket 实时通知用户"有其他用户在编辑"
3. **更细粒度的冲突检测**：基于文件内容差异而非版本号

## 七、总结

### 7.1 回答你的问题

**Q: 多人协同编辑保存时会不会有冲突？**

**A: 保存时不会有冲突，但发布时可能检测到冲突。**

**原因**：
- 保存时只是创建草稿版本，多个草稿可以并存
- 冲突检测在**发布时**进行，通过 `baseVersion` 与 `publishedVersion` 比较
- 如果草稿基于的版本已被其他用户更新，会检测到冲突

### 7.2 冲突处理方式

1. **自动合并**：如果修改的区域不冲突，系统自动合并
2. **手动解决**：如果修改的区域冲突，用户需要手动选择保留哪边的修改

### 7.3 设计优势

- ✅ **不会丢失数据**：所有编辑都会保存为草稿版本
- ✅ **冲突可追溯**：通过 `baseVersion` 可以清楚地看到冲突原因
- ✅ **灵活处理**：支持自动合并和手动解决两种方式

### 7.4 潜在改进

- 🔄 **保存时预检测**：提前提示用户有冲突风险
- 🔄 **实时协作提示**：显示当前有多少用户在编辑
- 🔄 **文件级冲突检测**：OnlyOffice 本身支持协作编辑，但需要配置协作服务器（CoEditing 模式）

---

## 附录：OnlyOffice 协作模式说明

OnlyOffice 支持两种协作模式：

1. **Fast Co-editing（快速协作）**：
   - 多个用户同时编辑，修改会实时同步
   - 需要配置 OnlyOffice 的协作服务器
   - 系统当前未启用此模式

2. **Strict Co-editing（严格协作）**：
   - 需要锁定机制，同一时间只有一个人可以编辑
   - 系统当前未实现锁定机制

**当前系统使用的是默认模式**：每个用户独立编辑，保存时创建新版本，发布时检测冲突。
